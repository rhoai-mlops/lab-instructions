# Model Deployment via GitOps

We deployed our `jukebox` model in experiment environment manually, but for the higher environments we need to store the definitions in Git and deploy our models via Argo CD to get all the benefits that GitOps brings.

## üöó Modelcar and GitOpsifying the Deployment

When a new model version is generated by the training pipeline, whether triggered by a code change or a monitoring alert, our goal is to ensure it‚Äôs deployed automatically if it shows better performance (no worries, we'll make sure only the best models make it, just hang in there üòâ). Alongside automation, we prioritize traceability, immutability, and reproducibility in the deployment process.

To support these requirements, we use KServe's **ModelCars**, a feature designed to simplify model deployment by containerizing models as Open Container Initiative (OCI) images. We are essentially using these ModelCars as model storage for our model servers.  
With ModelCars, each model version is packaged into a container image, allowing us to leverage benefits like version tracking and streamlined scaling.

When the pipeline detects a git push event, it tags the model version with the git commit ID. This identifier links the model back to its source code changes, giving us context on why and how it was built.

Once the model artifact and its versioning info are created, the pipeline pushes this update to the `mlops-gitops/model-deployment/` repository. Argo CD then recognizes this change, updating the `InferenceService` configuration in OpenShift. This triggers an automated rollout of the new model version, seamlessly integrating it into production.

## Deploying Jukebox

1. Just like we did with our toolings, we need to generate `ApplicationSet` definition for our model deployment. We will have two seperate AppSet definition; one is for `test` and one is for `prod` environment. For the enablement simplicity reasons, we keep them in the same repository. However in the real life, you may also like to take prod definitions into another repository where you only make changes via Pull Requests with a protected `main` branch. We keep AppSet definition separate so that it'll be easy to take the prod definition into another place later on :)

Let's update the AppSet definition with `CLUSTER_DOMAIN` and `USER_NAME` definition just like before. Open up the `appset-test.yaml` and `appset-prod.yaml` files and replace the values. For the lazy ones we also have the commands:

  ```bash
      sed -i -e 's/CLUSTER_DOMAIN/<CLUSTER_DOMAIN>/g' /opt/app-root/src/mlops-gitops/appset-test.yaml
      sed -i -e 's/USER_NAME/<USER_NAME>/g' /opt/app-root/src/mlops-gitops/appset-test.yaml
      sed -i -e 's/CLUSTER_DOMAIN/<CLUSTER_DOMAIN>/g' /opt/app-root/src/mlops-gitops/appset-prod.yaml
      sed -i -e 's/USER_NAME/<USER_NAME>/g' /opt/app-root/src/mlops-gitops/appset-prod.yaml
  ```


2. Let's add `jukebox` model definition under `model-deployments/test/jukebox/config.yaml` and `model-deployments/prod/jukebox/config.yaml` files as follow. This will take a model deployment helm-chart from a generic helm chart repository and apply the additional configuration such as image version.  

    ```yaml
    chart_path: charts/model-deployment/simple
    name: jukebox
    version: latest
    image_repository: quay.io
    image_namespace: rhoai-mlops
    ```
    
3. Let's get this deployed of course - it's not real unless its in git!

    ```bash
    cd /opt/app-root/src/mlops-gitops
    git add .
    git commit -m  "üê∞ ADD - appsets and jukebox to deploy üê∞"
    git push 
    ```

4. With the `jukebox` values stored in Git, now let's tell Argo CD to start picking up changes to these environments. To do this, simply we need to create ApplicationSets:

    ```bash
    oc apply -f /opt/app-root/src/mlops-gitops/appset-test.yaml -n <USER_NAME>-mlops
    oc apply -f /opt/app-root/src/mlops-gitops/appset-prod.yaml -n <USER_NAME>-mlops
    ```

5. You should see the two Jukebox application, one for `test` and one for `prod` deployed in Argo CD. 
![argocd-jukebox-deployed](./images/argocd-jukebox-deployed.png)

6. You can also go to RHOAI, select Model Serving in the left menu and then select one of the two projects to see the deployed models from OpenShift AI's Dashboard, just like we did in the inner loop.
![rhoai-deployed-models](./images/rhoai-deployed-models.png)

## Using the Jukebox UI

As you can see from the ArgoCD UI we have also created applications for an UI for the jukebox model, both in test and prod. However, if you were to look inside them you will see that they are empty.  

Let's go ahead and get our UI deployed! üì∫

1. Similar to with the jukebox model, we will update the currently empty `model-deployments/test/jukebox-ui/config.yaml` and `model-deployments/prod/jukebox-ui/config.yaml` with the following:  

    * PROD:

    ```yaml
    repo_url: https://<GIT_SERVER>/<USER_NAME>/jukebox-ui
    chart_path: chart
    model_endpoint: https://jukebox-<USER_NAME>-prod.<CLUSTER_DOMAIN>
    input_node: input
    model_name: jukebox
    ```

    * TEST:

    ```yaml
    repo_url: https://<GIT_SERVER>/<USER_NAME>/jukebox-ui
    chart_path: chart
    model_endpoint: https://jukebox-<USER_NAME>-test.<CLUSTER_DOMAIN>
    input_node: input
    model_name: jukebox
    ```

2. Then just push it to git and see it update in ArgoCD üßô‚Äç‚ôÇÔ∏è

    ```bash
    cd /opt/app-root/src/mlops-gitops
    git add .
    git commit -m  "üê∞ UPDATE - jukebox-ui configs for deployment üê∞"
    git push 
    ```

3. Now with our fresh new UI deployed, we can take a look at it by going to this route:

    ```bash
    https://jukebox-ui-<USER_NAME>-test.<CLUSTER_DOMAIN>
    ```

4. Try to predict a new location! üó∫Ô∏è

![jukebox-ui](./images/jukebox-ui.png)
